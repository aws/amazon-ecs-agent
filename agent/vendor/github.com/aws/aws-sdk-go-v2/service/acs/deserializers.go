// Code generated by smithy-go-codegen DO NOT EDIT.


package acs

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"encoding/json"
	"github.com/aws/smithy-go/middleware"
	"github.com/aws/smithy-go/ptr"
	"github.com/aws/aws-sdk-go-v2/aws/protocol/restjson"
	smithy "github.com/aws/smithy-go"
	smithyhttp "github.com/aws/smithy-go/transport/http"
	smithyio "github.com/aws/smithy-go/io"
	smithytime "github.com/aws/smithy-go/time"
	"strings"
	"time"
	"github.com/aws/smithy-go/tracing"
	"github.com/aws/aws-sdk-go-v2/service/acs/types"
)

func deserializeS3Expires(v string) (*time.Time, error) {
    t, err := smithytime.ParseHTTPDate(v)
    if err != nil {
        return nil, nil
    }
    return &t, nil
}

type awsAwsjson11_deserializeOpAttachInstanceNetworkInterfaces struct {
}

func (*awsAwsjson11_deserializeOpAttachInstanceNetworkInterfaces) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpAttachInstanceNetworkInterfaces) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorAttachInstanceNetworkInterfaces(response, &metadata)
	}
	output := &AttachInstanceNetworkInterfacesOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	err = awsAwsjson11_deserializeOpDocumentAttachInstanceNetworkInterfacesOutput(&output, shape)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorAttachInstanceNetworkInterfaces(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpAttachTaskNetworkInterfaces struct {
}

func (*awsAwsjson11_deserializeOpAttachTaskNetworkInterfaces) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpAttachTaskNetworkInterfaces) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorAttachTaskNetworkInterfaces(response, &metadata)
	}
	output := &AttachTaskNetworkInterfacesOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	err = awsAwsjson11_deserializeOpDocumentAttachTaskNetworkInterfacesOutput(&output, shape)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorAttachTaskNetworkInterfaces(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpConfirmAttachment struct {
}

func (*awsAwsjson11_deserializeOpConfirmAttachment) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpConfirmAttachment) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorConfirmAttachment(response, &metadata)
	}
	output := &ConfirmAttachmentOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	err = awsAwsjson11_deserializeOpDocumentConfirmAttachmentOutput(&output, shape)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorConfirmAttachment(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpError struct {
}

func (*awsAwsjson11_deserializeOpError) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpError) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorError(response, &metadata)
	}
	output := &ErrorOutput{}
	out.Result = output
	
	if _, err = io.Copy(ioutil.Discard, response.Body); err != nil {
		return out, metadata, &smithy.DeserializationError{
			Err: fmt.Errorf("failed to discard response body, %w", err),
		}
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorError(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpHeartbeat struct {
}

func (*awsAwsjson11_deserializeOpHeartbeat) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpHeartbeat) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorHeartbeat(response, &metadata)
	}
	output := &HeartbeatOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	err = awsAwsjson11_deserializeOpDocumentHeartbeatOutput(&output, shape)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorHeartbeat(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpPayload struct {
}

func (*awsAwsjson11_deserializeOpPayload) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpPayload) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorPayload(response, &metadata)
	}
	output := &PayloadOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	err = awsAwsjson11_deserializeOpDocumentPayloadOutput(&output, shape)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorPayload(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpPerformUpdate struct {
}

func (*awsAwsjson11_deserializeOpPerformUpdate) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpPerformUpdate) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorPerformUpdate(response, &metadata)
	}
	output := &PerformUpdateOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	err = awsAwsjson11_deserializeOpDocumentPerformUpdateOutput(&output, shape)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorPerformUpdate(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpPoll struct {
}

func (*awsAwsjson11_deserializeOpPoll) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpPoll) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorPoll(response, &metadata)
	}
	output := &PollOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	err = awsAwsjson11_deserializeOpDocumentPollOutput(&output, shape)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorPoll(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		case strings.EqualFold("AccessDeniedException", errorCode):
			return awsAwsjson11_deserializeErrorAccessDeniedException(response, errorBody)
		
		case strings.EqualFold("BadRequestException", errorCode):
			return awsAwsjson11_deserializeErrorBadRequestException(response, errorBody)
		
		case strings.EqualFold("InactiveInstanceException", errorCode):
			return awsAwsjson11_deserializeErrorInactiveInstanceException(response, errorBody)
		
		case strings.EqualFold("InvalidClusterException", errorCode):
			return awsAwsjson11_deserializeErrorInvalidClusterException(response, errorBody)
		
		case strings.EqualFold("InvalidInstanceException", errorCode):
			return awsAwsjson11_deserializeErrorInvalidInstanceException(response, errorBody)
		
		case strings.EqualFold("ServerException", errorCode):
			return awsAwsjson11_deserializeErrorServerException(response, errorBody)
		
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpRefreshTaskIAMRoleCredentials struct {
}

func (*awsAwsjson11_deserializeOpRefreshTaskIAMRoleCredentials) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpRefreshTaskIAMRoleCredentials) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorRefreshTaskIAMRoleCredentials(response, &metadata)
	}
	output := &RefreshTaskIAMRoleCredentialsOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	err = awsAwsjson11_deserializeOpDocumentRefreshTaskIAMRoleCredentialsOutput(&output, shape)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorRefreshTaskIAMRoleCredentials(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpStageUpdate struct {
}

func (*awsAwsjson11_deserializeOpStageUpdate) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpStageUpdate) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorStageUpdate(response, &metadata)
	}
	output := &StageUpdateOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	err = awsAwsjson11_deserializeOpDocumentStageUpdateOutput(&output, shape)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorStageUpdate(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpTaskManifest struct {
}

func (*awsAwsjson11_deserializeOpTaskManifest) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpTaskManifest) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorTaskManifest(response, &metadata)
	}
	output := &TaskManifestOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	err = awsAwsjson11_deserializeOpDocumentTaskManifestOutput(&output, shape)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorTaskManifest(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpTaskStopVerification struct {
}

func (*awsAwsjson11_deserializeOpTaskStopVerification) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpTaskStopVerification) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorTaskStopVerification(response, &metadata)
	}
	output := &TaskStopVerificationOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	err = awsAwsjson11_deserializeOpDocumentTaskStopVerificationOutput(&output, shape)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorTaskStopVerification(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsjson11_deserializeOpUpdateFailure struct {
}

func (*awsAwsjson11_deserializeOpUpdateFailure) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdateFailure) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	_, span := tracing.StartSpan(ctx, "OperationDeserializer")
	endTimer := startMetricTimer(ctx, "client.call.deserialization_duration")
	defer endTimer()
	defer span.End()
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdateFailure(response, &metadata)
	}
	output := &UpdateFailureOutput{}
	out.Result = output
	
	if _, err = io.Copy(ioutil.Discard, response.Body); err != nil {
		return out, metadata, &smithy.DeserializationError{
			Err: fmt.Errorf("failed to discard response body, %w", err),
		}
	}
	
	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdateFailure(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	headerCode := response.Header.Get("X-Amzn-ErrorType")
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	bodyInfo, err := getProtocolErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	if typ, ok := resolveProtocolErrorType(headerCode, bodyInfo); ok {
	    errorCode = restjson.SanitizeErrorCode(typ)
	}
	if len(bodyInfo.Message) != 0 {
	    errorMessage = bodyInfo.Message
	}
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

func awsAwsjson11_deserializeErrorAccessDeniedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	output := &types.AccessDeniedException{}
	err := awsAwsjson11_deserializeDocumentAccessDeniedException(&output, shape)
	
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorBadRequestException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	output := &types.BadRequestException{}
	err := awsAwsjson11_deserializeDocumentBadRequestException(&output, shape)
	
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInactiveInstanceException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	output := &types.InactiveInstanceException{}
	err := awsAwsjson11_deserializeDocumentInactiveInstanceException(&output, shape)
	
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidClusterException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	output := &types.InvalidClusterException{}
	err := awsAwsjson11_deserializeDocumentInvalidClusterException(&output, shape)
	
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidInstanceException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	output := &types.InvalidInstanceException{}
	err := awsAwsjson11_deserializeDocumentInvalidInstanceException(&output, shape)
	
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorServerException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	
	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()
	var shape interface{}
	if err := decoder.Decode(&shape); err != nil && err != io.EOF {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	output := &types.ServerException{}
	err := awsAwsjson11_deserializeDocumentServerException(&output, shape)
	
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return err
	}
	
	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeDocumentAccessDeniedException(v **types.AccessDeniedException, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *types.AccessDeniedException
	if *v == nil {
		sv = &types.AccessDeniedException{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "message", "Message":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Message = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBadRequestException(v **types.BadRequestException, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *types.BadRequestException
	if *v == nil {
		sv = &types.BadRequestException{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "message", "Message":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Message = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInactiveInstanceException(v **types.InactiveInstanceException, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *types.InactiveInstanceException
	if *v == nil {
		sv = &types.InactiveInstanceException{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "message", "Message":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Message = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidClusterException(v **types.InvalidClusterException, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *types.InvalidClusterException
	if *v == nil {
		sv = &types.InvalidClusterException{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "message", "Message":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Message = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidInstanceException(v **types.InvalidInstanceException, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *types.InvalidInstanceException
	if *v == nil {
		sv = &types.InvalidInstanceException{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "message", "Message":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Message = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentServerException(v **types.ServerException, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *types.ServerException
	if *v == nil {
		sv = &types.ServerException{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "message", "Message":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Message = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentTaskIdentifier(v **types.TaskIdentifier, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *types.TaskIdentifier
	if *v == nil {
		sv = &types.TaskIdentifier{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "desiredStatus":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.DesiredStatus = ptr.String(jtv)
			}
			
			case "taskArn":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.TaskArn = ptr.String(jtv)
			}
			
			case "taskClusterArn":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.TaskClusterArn = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentTaskIdentifierList(v *[]types.TaskIdentifier, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.([]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var cv []types.TaskIdentifier
	if *v == nil {
		cv = []types.TaskIdentifier{}
		} else {
			cv = *v
		}
	
	for _, value := range shape {
		var col types.TaskIdentifier
		destAddr := &col
		if err := awsAwsjson11_deserializeDocumentTaskIdentifier(&destAddr, value); err != nil {
			return err
		}
		col = *destAddr
		cv = append(cv, col)
		
	}
	*v = cv
	return nil
}

func awsAwsjson11_deserializeOpDocumentAttachInstanceNetworkInterfacesOutput(v **AttachInstanceNetworkInterfacesOutput, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *AttachInstanceNetworkInterfacesOutput
	if *v == nil {
		sv = &AttachInstanceNetworkInterfacesOutput{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "cluster":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Cluster = ptr.String(jtv)
			}
			
			case "containerInstance":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.ContainerInstance = ptr.String(jtv)
			}
			
			case "messageId":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.MessageId = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentAttachTaskNetworkInterfacesOutput(v **AttachTaskNetworkInterfacesOutput, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *AttachTaskNetworkInterfacesOutput
	if *v == nil {
		sv = &AttachTaskNetworkInterfacesOutput{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "cluster":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Cluster = ptr.String(jtv)
			}
			
			case "containerInstance":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.ContainerInstance = ptr.String(jtv)
			}
			
			case "messageId":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.MessageId = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentConfirmAttachmentOutput(v **ConfirmAttachmentOutput, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *ConfirmAttachmentOutput
	if *v == nil {
		sv = &ConfirmAttachmentOutput{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "cluster":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Cluster = ptr.String(jtv)
			}
			
			case "containerInstance":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.ContainerInstance = ptr.String(jtv)
			}
			
			case "messageId":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.MessageId = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentHeartbeatOutput(v **HeartbeatOutput, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *HeartbeatOutput
	if *v == nil {
		sv = &HeartbeatOutput{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "messageId":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.MessageId = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentPayloadOutput(v **PayloadOutput, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *PayloadOutput
	if *v == nil {
		sv = &PayloadOutput{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "cluster":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Cluster = ptr.String(jtv)
			}
			
			case "containerInstance":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.ContainerInstance = ptr.String(jtv)
			}
			
			case "messageId":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.MessageId = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentPerformUpdateOutput(v **PerformUpdateOutput, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *PerformUpdateOutput
	if *v == nil {
		sv = &PerformUpdateOutput{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "cluster":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Cluster = ptr.String(jtv)
			}
			
			case "containerInstance":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.ContainerInstance = ptr.String(jtv)
			}
			
			case "messageId":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.MessageId = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentPollOutput(v **PollOutput, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *PollOutput
	if *v == nil {
		sv = &PollOutput{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "message":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Message = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentRefreshTaskIAMRoleCredentialsOutput(v **RefreshTaskIAMRoleCredentialsOutput, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *RefreshTaskIAMRoleCredentialsOutput
	if *v == nil {
		sv = &RefreshTaskIAMRoleCredentialsOutput{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "credentialsId":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.CredentialsId = ptr.String(jtv)
			}
			
			case "expiration":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Expiration = ptr.String(jtv)
			}
			
			case "messageId":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.MessageId = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentStageUpdateOutput(v **StageUpdateOutput, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *StageUpdateOutput
	if *v == nil {
		sv = &StageUpdateOutput{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "cluster":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Cluster = ptr.String(jtv)
			}
			
			case "containerInstance":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.ContainerInstance = ptr.String(jtv)
			}
			
			case "messageId":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.MessageId = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentTaskManifestOutput(v **TaskManifestOutput, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *TaskManifestOutput
	if *v == nil {
		sv = &TaskManifestOutput{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "cluster":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.Cluster = ptr.String(jtv)
			}
			
			case "containerInstance":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.ContainerInstance = ptr.String(jtv)
			}
			
			case "messageId":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.MessageId = ptr.String(jtv)
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentTaskStopVerificationOutput(v **TaskStopVerificationOutput, value interface{}) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	if value == nil {
		return nil
	}
	
	shape, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Errorf("unexpected JSON type %v", value)
	}
	
	var sv *TaskStopVerificationOutput
	if *v == nil {
		sv = &TaskStopVerificationOutput{}
		} else {
			sv = *v
		}
	
	for key, value := range shape {
		switch key {
			case "generatedAt":
			if value != nil {
				jtv, ok := value.(json.Number)
				if !ok {
					return fmt.Errorf("expected Long to be json.Number, got %T instead", value)
				}
				i64, err := jtv.Int64()
				if err != nil { return err }
				sv.GeneratedAt = ptr.Int64(i64)
			}
			
			case "messageId":
			if value != nil {
				jtv, ok := value.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", value)
				}
				sv.MessageId = ptr.String(jtv)
			}
			
			case "stopTasks":
			if err := awsAwsjson11_deserializeDocumentTaskIdentifierList(&sv.StopTasks, value); err != nil {
				return err
			}
			
			default:
				_, _ = key, value
			
		}
	}
	*v = sv
	return nil
}

type protocolErrorInfo struct {
    Type    string `json:"__type"`
    Message string
    Code    any // nonstandard for awsjson but some services do present the type here
}

func getProtocolErrorInfo(decoder *json.Decoder) (protocolErrorInfo, error) {
    var errInfo protocolErrorInfo
    if err := decoder.Decode(&errInfo); err != nil {
        if err == io.EOF {
            return errInfo, nil
        }
        return errInfo, err
    }

    return errInfo, nil
}

func resolveProtocolErrorType(headerType string, bodyInfo protocolErrorInfo) (string, bool) {
    if len(headerType) != 0 {
        return headerType, true
    } else if len(bodyInfo.Type) != 0 {
        return bodyInfo.Type, true
    } else if code, ok := bodyInfo.Code.(string); ok && len(code) != 0 {
        return code, true
    }
    return "", false
}
